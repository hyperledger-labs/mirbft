/*
Copyright IBM Corp. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

syntax = "proto3";

package isspb;

import "isspbftpb/isspbftpb.proto";
import "requestpb/requestpb.proto";

option go_package = "github.com/hyperledger-labs/mirbft/pkg/pb/isspb";

// ============================================================
// Messages
// ============================================================

message ISSMessage {
  oneof type {
    SBMessage          sb                  = 1;
    Checkpoint         checkpoint          = 2;
    RetransmitRequests retransmit_requests = 3;
  }
}

message RetransmitRequests {
  repeated requestpb.RequestRef requests = 1;
}

message SBMessage {
  uint64 epoch = 1;
  uint64 instance = 2;
  SBInstanceMessage msg = 3;
}

message Checkpoint {
  uint64 epoch = 1;
  uint64 sn    = 2;
}

message SBInstanceMessage {
  oneof type {
    isspbftpb.Preprepare pbft_preprepare = 1;
    isspbftpb.Prepare    pbft_prepare    = 2;
    isspbftpb.Commit     pbft_commit     = 3;
  }
}

// ============================================================
// Events
// ============================================================

message ISSEvent {
  oneof type {
    PersistCheckpoint       persist_checkpoint        = 1;
    StableCheckpoint        stable_checkpoint         = 2;
    PersistStableCheckpoint persist_stable_checkpoint = 3;
    SBEvent                 sb                        = 4;
  }
}

message ISSHashOrigin {
  oneof type {
    SBHashOrigin   sb        = 1;
    CommitLogEntry log_entry = 2;
  }
}

// The commitLogEntry type represents an entry of the commit log, the final output of the ordering process.
// Whenever an orderer delivers a batch (or a special abort value),
// it is inserted to the commit log in form of a commitLogEntry.
message CommitLogEntry {

  // Sequence number at which this entry has been ordered.
  uint64          sn      = 1;

  // The delivered request batch.
  requestpb.Batch batch   = 2;

  // The digest (hash) of the batch.
  bytes           digest  = 3;

  // A flag indicating whether this entry is an actual request batch (false)
  // or whether the orderer delivered a special abort value (true).
  bool            aborted = 4;

  // In case Aborted is true, this field indicates the ID of the node
  // that is suspected to be the reason for the orderer aborting (usually the leader).
  // This information can be used by the leader selection policy at epoch transition.
  uint64          suspect = 5;
}

message PersistCheckpoint {
  uint64 sn           = 1;
  bytes  app_snapshot = 2;
}

message StableCheckpoint {
  uint64 epoch = 1;
  uint64 sn    = 2;
  // TODO: Some form of checkpoint certificate will need to go here.
}

// PersistStableCheckpoint needs to be a separate Event from StableCheckpoint, since both are ISSEvents,
// but, the protocol must differentiate between them. While the former will be applied on recovery from the WAL,
// the latter serves as a notification to the ISS protocol when a stable checkpoint has been persisted.
message PersistStableCheckpoint {
  StableCheckpoint stable_checkpoint = 1;
}

message SBEvent {
  uint64 epoch = 1;
  uint64 instance = 2;
  SBInstanceEvent event = 3;
}

message SBInstanceEvent {
  oneof type {
    SBInit            init              = 1;
    SBDeliver         deliver           = 2;
    SBMessageReceived message_received  = 3;
    SBPendingRequests pending_requests  = 4;
    SBTick            tick              = 5;
    SBCutBatch        cut_batch         = 6;
    SBBatchReady      batch_ready       = 7;
    SBWaitForRequests wait_for_requests = 8;
    SBRequestsReady   requests_ready    = 9;
    SBHashRequest     hash_request      = 10;
    SBHashResult      hash_result       = 11;

    isspbftpb.PersistPreprepare    pbft_persist_preprepare = 12;
    isspbftpb.PersistPrepare       pbft_persist_prepare    = 13;
    isspbftpb.PersistCommit        pbft_persist_commit     = 14;
    //isspbftpb.PreprepareHashResult pbft_hash_result        = 15;
  }
}

message SBInit {}

message SBCutBatch {
  uint64 max_size = 1;
}

message SBBatchReady {
  requestpb.Batch batch = 1;
  uint64 pending_requests_left = 2;
}

message SBWaitForRequests {
  SBReqWaitReference reference = 1;
  repeated requestpb.RequestRef requests = 2;
}

message SBReqWaitReference {
  oneof type {
    isspbftpb.ReqWaitReference pbft = 1;
  }
}

message SBRequestsReady {
  SBReqWaitReference ref = 1;
}

message SBDeliver {
  uint64          sn      = 1;
  requestpb.Batch batch   = 2;
  bool            aborted = 3;
}

message SBMessageReceived {
  uint64 from = 1;
  SBInstanceMessage msg = 2;
}

message SBPendingRequests {
  uint64 numRequests = 1;
}

message SBTick {
}

message SBHashResult {
  bytes                digest = 1;
  SBInstanceHashOrigin origin = 2;
}

message SBHashRequest {
  repeated bytes data   = 1;
  SBHashOrigin   origin = 2;
}

message SBHashOrigin {
  uint64 epoch = 1;
  uint64 instance = 2;
  SBInstanceHashOrigin origin = 3;
}

message SBInstanceHashOrigin {
  oneof type {
    isspbftpb.PreprepareHashOrigin pbft_preprepare = 1;
  }
}

// ============================================================
// Status
// ============================================================

message Status {
  uint64 epoch = 1;
  repeated SBStatus orderers = 2;
  // TODO: Represent whole status here.
}

message SBStatus {
  uint64 leader = 1;
  // TODO: Represent whole status here, e.g., the segment etc.
  //       Put common SB-related fields here and add a field for subprotocol-specific status.
}
