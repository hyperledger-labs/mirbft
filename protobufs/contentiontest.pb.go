// Code generated by protoc-gen-go. DO NOT EDIT.
// source: contentiontest.proto

package protobufs

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ControlCommand_Cmd int32

const (
	ControlCommand_START_STAT ControlCommand_Cmd = 0
	ControlCommand_STOP_STAT  ControlCommand_Cmd = 1
)

var ControlCommand_Cmd_name = map[int32]string{
	0: "START_STAT",
	1: "STOP_STAT",
}

var ControlCommand_Cmd_value = map[string]int32{
	"START_STAT": 0,
	"STOP_STAT":  1,
}

func (x ControlCommand_Cmd) String() string {
	return proto.EnumName(ControlCommand_Cmd_name, int32(x))
}

func (ControlCommand_Cmd) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c215ef7276364443, []int{0, 0}
}

type ControlCommand struct {
	Cmd                  ControlCommand_Cmd `protobuf:"varint,1,opt,name=cmd,proto3,enum=protobufs.ControlCommand_Cmd" json:"cmd,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ControlCommand) Reset()         { *m = ControlCommand{} }
func (m *ControlCommand) String() string { return proto.CompactTextString(m) }
func (*ControlCommand) ProtoMessage()    {}
func (*ControlCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_c215ef7276364443, []int{0}
}

func (m *ControlCommand) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControlCommand.Unmarshal(m, b)
}
func (m *ControlCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControlCommand.Marshal(b, m, deterministic)
}
func (m *ControlCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlCommand.Merge(m, src)
}
func (m *ControlCommand) XXX_Size() int {
	return xxx_messageInfo_ControlCommand.Size(m)
}
func (m *ControlCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlCommand.DiscardUnknown(m)
}

var xxx_messageInfo_ControlCommand proto.InternalMessageInfo

func (m *ControlCommand) GetCmd() ControlCommand_Cmd {
	if m != nil {
		return m.Cmd
	}
	return ControlCommand_START_STAT
}

type ControlResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ControlResponse) Reset()         { *m = ControlResponse{} }
func (m *ControlResponse) String() string { return proto.CompactTextString(m) }
func (*ControlResponse) ProtoMessage()    {}
func (*ControlResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c215ef7276364443, []int{1}
}

func (m *ControlResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControlResponse.Unmarshal(m, b)
}
func (m *ControlResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControlResponse.Marshal(b, m, deterministic)
}
func (m *ControlResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlResponse.Merge(m, src)
}
func (m *ControlResponse) XXX_Size() int {
	return xxx_messageInfo_ControlResponse.Size(m)
}
func (m *ControlResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ControlResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("protobufs.ControlCommand_Cmd", ControlCommand_Cmd_name, ControlCommand_Cmd_value)
	proto.RegisterType((*ControlCommand)(nil), "protobufs.ControlCommand")
	proto.RegisterType((*ControlResponse)(nil), "protobufs.ControlResponse")
}

func init() {
	proto.RegisterFile("contentiontest.proto", fileDescriptor_c215ef7276364443)
}

var fileDescriptor_c215ef7276364443 = []byte{
	// 245 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x49, 0xce, 0xcf, 0x2b,
	0x49, 0xcd, 0x2b, 0xc9, 0x04, 0x51, 0xc5, 0x25, 0x7a, 0x05, 0x45, 0xf9, 0x25, 0xf9, 0x42, 0x9c,
	0x60, 0x2a, 0xa9, 0x34, 0xad, 0x58, 0x8a, 0xb7, 0x28, 0xb5, 0xb0, 0x14, 0x2e, 0xa3, 0x94, 0xce,
	0xc5, 0xe7, 0x9c, 0x9f, 0x57, 0x52, 0x94, 0x9f, 0xe3, 0x9c, 0x9f, 0x9b, 0x9b, 0x98, 0x97, 0x22,
	0xa4, 0xcf, 0xc5, 0x9c, 0x9c, 0x9b, 0x22, 0xc1, 0xa8, 0xc0, 0xa8, 0xc1, 0x67, 0x24, 0xab, 0x07,
	0xd7, 0xa9, 0x87, 0xaa, 0x4e, 0xcf, 0x39, 0x37, 0x25, 0x08, 0xa4, 0x52, 0x49, 0x85, 0x8b, 0xd9,
	0x39, 0x37, 0x45, 0x88, 0x8f, 0x8b, 0x2b, 0x38, 0xc4, 0x31, 0x28, 0x24, 0x3e, 0x38, 0xc4, 0x31,
	0x44, 0x80, 0x41, 0x88, 0x97, 0x8b, 0x33, 0x38, 0xc4, 0x3f, 0x00, 0xc2, 0x65, 0x54, 0x12, 0xe4,
	0xe2, 0x87, 0x1a, 0x10, 0x94, 0x5a, 0x5c, 0x90, 0x9f, 0x57, 0x9c, 0x6a, 0x34, 0x9f, 0x11, 0x22,
	0x06, 0x71, 0x6e, 0x48, 0x6a, 0x71, 0x89, 0x81, 0x90, 0x17, 0x17, 0x3f, 0x88, 0x81, 0x10, 0x36,
	0x10, 0x92, 0x40, 0x76, 0x43, 0x4e, 0x66, 0x6a, 0x5e, 0x49, 0x10, 0xc4, 0x0b, 0x52, 0x92, 0x58,
	0x64, 0x20, 0x66, 0x6b, 0x30, 0x1a, 0x30, 0x0a, 0x39, 0x70, 0xb1, 0x43, 0xad, 0x14, 0x92, 0xc4,
	0xe9, 0x0f, 0x29, 0x29, 0x4c, 0x29, 0x3c, 0x2e, 0x34, 0xc4, 0x74, 0xa1, 0xe1, 0x40, 0xba, 0x30,
	0x92, 0x4b, 0x14, 0xd5, 0x81, 0x30, 0xf3, 0x28, 0x36, 0xda, 0x89, 0x2f, 0x8a, 0x47, 0x4f, 0xdf,
	0x1a, 0x2e, 0x9f, 0xc4, 0x06, 0x66, 0x1a, 0x03, 0x02, 0x00, 0x00, 0xff, 0xff, 0x70, 0x77, 0x2f,
	0x2f, 0x63, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ContentionTest0Client is the client API for ContentionTest0 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ContentionTest0Client interface {
	TestContention0(ctx context.Context, opts ...grpc.CallOption) (ContentionTest0_TestContention0Client, error)
	Control(ctx context.Context, in *ControlCommand, opts ...grpc.CallOption) (*ControlResponse, error)
}

type contentionTest0Client struct {
	cc grpc.ClientConnInterface
}

func NewContentionTest0Client(cc grpc.ClientConnInterface) ContentionTest0Client {
	return &contentionTest0Client{cc}
}

func (c *contentionTest0Client) TestContention0(ctx context.Context, opts ...grpc.CallOption) (ContentionTest0_TestContention0Client, error) {
	stream, err := c.cc.NewStream(ctx, &_ContentionTest0_serviceDesc.Streams[0], "/protobufs.ContentionTest0/TestContention0", opts...)
	if err != nil {
		return nil, err
	}
	x := &contentionTest0TestContention0Client{stream}
	return x, nil
}

type ContentionTest0_TestContention0Client interface {
	Send(*ClientRequest) error
	Recv() (*ClientResponse, error)
	grpc.ClientStream
}

type contentionTest0TestContention0Client struct {
	grpc.ClientStream
}

func (x *contentionTest0TestContention0Client) Send(m *ClientRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *contentionTest0TestContention0Client) Recv() (*ClientResponse, error) {
	m := new(ClientResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *contentionTest0Client) Control(ctx context.Context, in *ControlCommand, opts ...grpc.CallOption) (*ControlResponse, error) {
	out := new(ControlResponse)
	err := c.cc.Invoke(ctx, "/protobufs.ContentionTest0/Control", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContentionTest0Server is the server API for ContentionTest0 service.
type ContentionTest0Server interface {
	TestContention0(ContentionTest0_TestContention0Server) error
	Control(context.Context, *ControlCommand) (*ControlResponse, error)
}

// UnimplementedContentionTest0Server can be embedded to have forward compatible implementations.
type UnimplementedContentionTest0Server struct {
}

func (*UnimplementedContentionTest0Server) TestContention0(srv ContentionTest0_TestContention0Server) error {
	return status.Errorf(codes.Unimplemented, "method TestContention0 not implemented")
}
func (*UnimplementedContentionTest0Server) Control(ctx context.Context, req *ControlCommand) (*ControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Control not implemented")
}

func RegisterContentionTest0Server(s *grpc.Server, srv ContentionTest0Server) {
	s.RegisterService(&_ContentionTest0_serviceDesc, srv)
}

func _ContentionTest0_TestContention0_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ContentionTest0Server).TestContention0(&contentionTest0TestContention0Server{stream})
}

type ContentionTest0_TestContention0Server interface {
	Send(*ClientResponse) error
	Recv() (*ClientRequest, error)
	grpc.ServerStream
}

type contentionTest0TestContention0Server struct {
	grpc.ServerStream
}

func (x *contentionTest0TestContention0Server) Send(m *ClientResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *contentionTest0TestContention0Server) Recv() (*ClientRequest, error) {
	m := new(ClientRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ContentionTest0_Control_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ControlCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentionTest0Server).Control(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobufs.ContentionTest0/Control",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentionTest0Server).Control(ctx, req.(*ControlCommand))
	}
	return interceptor(ctx, in, info, handler)
}

var _ContentionTest0_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protobufs.ContentionTest0",
	HandlerType: (*ContentionTest0Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Control",
			Handler:    _ContentionTest0_Control_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TestContention0",
			Handler:       _ContentionTest0_TestContention0_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "contentiontest.proto",
}

// ContentionTest1Client is the client API for ContentionTest1 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ContentionTest1Client interface {
	TestContention1(ctx context.Context, opts ...grpc.CallOption) (ContentionTest1_TestContention1Client, error)
	Control(ctx context.Context, in *ControlCommand, opts ...grpc.CallOption) (*ControlResponse, error)
}

type contentionTest1Client struct {
	cc grpc.ClientConnInterface
}

func NewContentionTest1Client(cc grpc.ClientConnInterface) ContentionTest1Client {
	return &contentionTest1Client{cc}
}

func (c *contentionTest1Client) TestContention1(ctx context.Context, opts ...grpc.CallOption) (ContentionTest1_TestContention1Client, error) {
	stream, err := c.cc.NewStream(ctx, &_ContentionTest1_serviceDesc.Streams[0], "/protobufs.ContentionTest1/TestContention1", opts...)
	if err != nil {
		return nil, err
	}
	x := &contentionTest1TestContention1Client{stream}
	return x, nil
}

type ContentionTest1_TestContention1Client interface {
	Send(*ClientRequest) error
	Recv() (*ClientResponse, error)
	grpc.ClientStream
}

type contentionTest1TestContention1Client struct {
	grpc.ClientStream
}

func (x *contentionTest1TestContention1Client) Send(m *ClientRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *contentionTest1TestContention1Client) Recv() (*ClientResponse, error) {
	m := new(ClientResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *contentionTest1Client) Control(ctx context.Context, in *ControlCommand, opts ...grpc.CallOption) (*ControlResponse, error) {
	out := new(ControlResponse)
	err := c.cc.Invoke(ctx, "/protobufs.ContentionTest1/Control", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContentionTest1Server is the server API for ContentionTest1 service.
type ContentionTest1Server interface {
	TestContention1(ContentionTest1_TestContention1Server) error
	Control(context.Context, *ControlCommand) (*ControlResponse, error)
}

// UnimplementedContentionTest1Server can be embedded to have forward compatible implementations.
type UnimplementedContentionTest1Server struct {
}

func (*UnimplementedContentionTest1Server) TestContention1(srv ContentionTest1_TestContention1Server) error {
	return status.Errorf(codes.Unimplemented, "method TestContention1 not implemented")
}
func (*UnimplementedContentionTest1Server) Control(ctx context.Context, req *ControlCommand) (*ControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Control not implemented")
}

func RegisterContentionTest1Server(s *grpc.Server, srv ContentionTest1Server) {
	s.RegisterService(&_ContentionTest1_serviceDesc, srv)
}

func _ContentionTest1_TestContention1_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ContentionTest1Server).TestContention1(&contentionTest1TestContention1Server{stream})
}

type ContentionTest1_TestContention1Server interface {
	Send(*ClientResponse) error
	Recv() (*ClientRequest, error)
	grpc.ServerStream
}

type contentionTest1TestContention1Server struct {
	grpc.ServerStream
}

func (x *contentionTest1TestContention1Server) Send(m *ClientResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *contentionTest1TestContention1Server) Recv() (*ClientRequest, error) {
	m := new(ClientRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ContentionTest1_Control_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ControlCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentionTest1Server).Control(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobufs.ContentionTest1/Control",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentionTest1Server).Control(ctx, req.(*ControlCommand))
	}
	return interceptor(ctx, in, info, handler)
}

var _ContentionTest1_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protobufs.ContentionTest1",
	HandlerType: (*ContentionTest1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Control",
			Handler:    _ContentionTest1_Control_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TestContention1",
			Handler:       _ContentionTest1_TestContention1_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "contentiontest.proto",
}

// ContentionTestControlClient is the client API for ContentionTestControl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ContentionTestControlClient interface {
	Control(ctx context.Context, in *ControlCommand, opts ...grpc.CallOption) (*ControlResponse, error)
}

type contentionTestControlClient struct {
	cc grpc.ClientConnInterface
}

func NewContentionTestControlClient(cc grpc.ClientConnInterface) ContentionTestControlClient {
	return &contentionTestControlClient{cc}
}

func (c *contentionTestControlClient) Control(ctx context.Context, in *ControlCommand, opts ...grpc.CallOption) (*ControlResponse, error) {
	out := new(ControlResponse)
	err := c.cc.Invoke(ctx, "/protobufs.ContentionTestControl/Control", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContentionTestControlServer is the server API for ContentionTestControl service.
type ContentionTestControlServer interface {
	Control(context.Context, *ControlCommand) (*ControlResponse, error)
}

// UnimplementedContentionTestControlServer can be embedded to have forward compatible implementations.
type UnimplementedContentionTestControlServer struct {
}

func (*UnimplementedContentionTestControlServer) Control(ctx context.Context, req *ControlCommand) (*ControlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Control not implemented")
}

func RegisterContentionTestControlServer(s *grpc.Server, srv ContentionTestControlServer) {
	s.RegisterService(&_ContentionTestControl_serviceDesc, srv)
}

func _ContentionTestControl_Control_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ControlCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContentionTestControlServer).Control(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protobufs.ContentionTestControl/Control",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContentionTestControlServer).Control(ctx, req.(*ControlCommand))
	}
	return interceptor(ctx, in, info, handler)
}

var _ContentionTestControl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protobufs.ContentionTestControl",
	HandlerType: (*ContentionTestControlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Control",
			Handler:    _ContentionTestControl_Control_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "contentiontest.proto",
}
